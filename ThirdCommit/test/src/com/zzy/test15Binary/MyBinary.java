package com.zzy.test15Binary;

/**
 * 二进制(Binary)：
 * 		十进制如何转化为二进制:
 * 			例：
 * 			10%2 = 0;10/2=5;
 * 			5%2 = 1;5/2=2;
 * 			2%2 = 0;2/2=1;
 * 			1%2 = 1;1/2<1;
 * 			所以结果是1010（2） = 10（10）
 * 		二进制转化为十进制：
 * 			1010（2）
 * 			=1*2^3+0*2^2+1*2^1+0*2^0
 * 			=8+0+2+0
 * 			=10
 * 			当前数值*2^位数
 * 二进制一共5个运算：
 * 		与（&）：0&1=0,1&0=0,0&0=0,1&1=1;(两个1才为1，否则为0)
 * 		或（|）：0|1=1,1|0=1,0|0=0,1|1=1;(两个0才为0，否则为1)
 * 		异或（^）:0^1=1,1^0=1,0^0=0,1^1=0;(相同为0，不同为1)
 * 		左移（<<）：00001010<<2 = 00101000(最左边n位将被丢弃，同时在最右边补上n个0)
 * 		右移（>>）:00001010<<2 = 00000010(最右边n位将被丢弃，同时在最左边补上n个0)
 * Java 中无符号右移为 ">>>" 
 * 面试题15：二进制中的1的个数：
 * 		剑指Offer为我们提供了三个解法：
 * 			第一个解法(若输入负数则可能引起死循环)：
 * 				先判断整数最右边是否为1，再右移1位
 * 				如何判断整数最右边为1？将最右边与1做与运算，是否为1
 * 			第二种解法：
 * 				使用左移
 * 			第三种解法：
 * 				有一个结论：将一个数-1之后与该数作位与运算，会将最右边的1都变成0。
 * 				1100-1 = 1011,1100|1011 = 1000
 * 				则按照这个结论，有几个1，就做几个这样的运算。这样做的意义是将最右边的1变成0
 * @author user
 *
 */

public class MyBinary {
	/**
	 * 我们使用第三种解法
	 */
	
	public int hammingWeight(int n) {
		int count = 0;
		while(n!=0) {
			count++;
			n = n&(n-1);
		}
        return count;
    }
	
	public int hammingWeight2(int n) {
		int count = 0;
		while(n!=0) {
			if((n%10 & 1) == 1) {
				count++;
			}
			n >>>= 1;
		}
        return count;
    }
	
}
